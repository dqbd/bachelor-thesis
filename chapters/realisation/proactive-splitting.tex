\section{Proactive Splitting}

As specified in operations of \cref{section:b-tree}, to perform an update operation, such as insertion or deletion, on a tree, the target node must be first found by traversing top-down. If the node fails to meet the rules \todo{explain rules} of the tree, a split or merge operation must occur, which requires propagation upwards and might cascade the changes to the root node. A pointer to a parent node stored in a node or a stack of visited notes must be implemented to have the ability to traverse back to the root, which brings additional complexity, especially on the GPU, where a kernel function cannot allocate new memory by itself, and the stack size must be known beforehand.

Thus, in the implementation found in this thesis, any splitting operations are done proactively, where splits occur before descending further down the tree. This method has the benefit of not visiting any node twice, thus guaranteeing every operation to update nodes in at most two levels and preventing any cascading back to the root. The implementation needs to track only two nodes simultaneously, thus avoiding implementing an explicit stack on the CUDA.

However, this method does come with the disadvantage of premature splitting, as the node does not know whether either of its descendants will become full, require a split, and cause a cascade back to the node. B-Trees implementing bottom-up insertion could do a smaller amount of splitting in general.
