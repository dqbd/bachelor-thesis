\section{Proactive Splitting}

As specified in operations of \cref{section:b-tree}, to perform an update operation, such as insertion or deletion, on a tree, the target node must be first found by traversing top-down. If the node becomes either full or does not have enough keys, a split or merge operation must occur, which requires propagation upwards and might cascade the changes to the root node. A pointer to a parent node stored in a node (whi) or a stack of visited notes must be implemented to have the ability to traverse back to the root, which brings additional unnecessary complexity to the GPU.

Thus, in the implementation found in this thesis, any splitting operations are done proactively, where splits occur before descending further down the tree. This method benefits from not visiting any node twice, guaranteeing every operation to update at most two levels, and preventing any cascading back to the root. Furthermore, the implementation needs to track only two nodes simultaneously, avoiding implementing an explicit stack on the device or keeping track of the parent node inside the node structure itself.

However, this method does come with the disadvantage of premature splitting, as the node does not know whether either of its descendants will become full, require a split, and cause a cascade back to the node. B-Trees implementing bottom-up insertion could do a smaller amount of splitting in general.
