\section{Motivation}

B-Tree is a well-known data structure often used as an index, a critical primitive used in various applications, such as data mining, decision support systems, and Online analytical processing (OLAP). Widely found in database systems and file systems, B-Tree became the de facto data structure used when dealing with a large amount of arbitrary data of an unknown domain.

Thanks to the self-balancing nature of this data structure by keeping the tree height as small as possible, regardless of arbitrary updates, lookup, insertion, and deletion in the tree are in $\mathcal{O}(\log{n})$. Naively, operating on multiple items will thus perform in $\mathcal{O}(n \log{n})$.

This can be improved upon by enabling parallel processing and computation on such data structure, the most popular method of the parallel computational platform being the Graphical Processing Units (GPU). With the advent of programmable shaders and support for floating-point operations, General-purpose computing on GPU became suitable for high-performance computing. Thanks to their superior computing performance to price ratio, GPUs became an essential staple for enabling high-performance computing for the masses.

Although GPUs have carved their niche and adopted some computational tasks, such as deep learning or cryptocurrency mining, a performant GPU implementation of B-tree is challenging. Proper care must be taken when implementing concurrency control to allow high-throughput GPU performance without compromising correctness.

Nevertheless, optimizing such data structure for GPU would allow us to utilize the parallel nature of GPU to accelerate querying and updating multiple items, unlocking the potential performance gains in all applications using B-trees for operating on data.

\section{Structure of Work}

The thesis' main work is to introduce an implementation of a B-Tree built on top of the Template Numerical Library (TNL). This implementation shall have the ability to switch the environment in which the data resides and operations are performed. Either on the CPU or the GPU. The code has to be implemented in \CC\ and must support CUDA, as these are the prerequisites of the used library.

First, in the theoretical section, hardware structure and software architecture will be introduced, alongside the general overview of prior art related to previous GPU implementations of B-Trees. A general primer of both the TNL library and the B-Tree data structure will also be present. Different variants and modifications of the data structure, such as B$^+$Tree or B-Link-Tree, are explained and compared against the original B-Tree in the context of massively parallel execution on the GPU.

The realization section presented in Chapter \ref{chapter:realisation} will explain the design decision choices made for this GPU B-Tree and delve into the actual code of the implementation.

Last but not least, the experimental results and comparison between the thesis' implementation and other CPU and GPU implementations are presented in Chapter \ref{section:results}.