\section{Motivation}

B-tree is a well known data structure. What it is used for? (Online Analytical Processing - OLAP, decision making systems such as DSS, data mining)

Computing performance per price makes GPU improtant for scientific computing.

Utilizing GPU to accelerate processing and index search yields great potential, demonstrated by 

High GPU bandwidth, problem arises with good GPU utilization and proper allocation of resources.



With the advent of programmable shaders and support for floating-point operations, General-purpose computing on Graphical Processing Units (GPU) became suitable for scientific computing. Their superior computing performance to price ratio makes 

Since then, GPUs have gained significant adoption for various computational tasks, such as deep learning, and became an essential staple for enabling high-performance computing for the masses.

Nevertheless, the toolbox for general purpose data structures is lacking. One such data structure commonly used in classical CPU systems is a B-Tree. B-Tree is a search tree data structure widely used in database systems and file systems. They became the de facto default data structure used to read a large amount of arbitrary data of an unknown domain.

Thanks to the self-balancing nature of this data structure by keeping the tree height as small as possible, regardless of arbitrary updates, lookup, insertion, and deletion in the tree are in $\mathcal{O}(\log{n})$. Naive updates of multiple items thus will run in $\mathcal{O}(n \log{n})$. Optimizing such data structure for GPU would allow us to utilize the parallel nature of GPU to accelerate querying and updating multiple items, unlocking potential performance gains in all applications using B-Trees for storing data.

\section{Structure of Work}

The thesis' main work is to introduce an implementation of a B-Tree built on top of the Template Numerical Library (TNL). This implementation shall have the ability to switch the environment in which the data resides and operations are performed. Either on the CPU or the GPU. The code has to be implemented in \CC\ and must support CUDA, as these are the prerequisites of the used library.

First, in the theoretical section, hardware structure and software architecture will be introduced, alongside the general overview of prior art related to previous GPU implementations of B-Trees. A general primer of both the TNL library and the B-Tree data structure will also be present. Different variants and modifications of the data structure, such as B+Tree or B-Link-Tree, are explained and compared against the original B-Tree in the context of massively parallel execution on the GPU.

The realization section presented in Chapter \ref{chapter:realisation} will explain the design decision choices made for this GPU B-Tree and delve into the actual code of the implementation.

Last but not least, the experimental results and comparison between the thesis' implementation and other CPU and GPU implementations are presented in Chapter \ref{section:results}.