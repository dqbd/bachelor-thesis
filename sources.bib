@manual{iso690,
  organization = {\'U\v rad pro technickou normalizaci, metrologii a st\'atn\'\i{} zku\v sebnictv\'\i{}},
  title        = {\v CSN ISO 690 Informace a dokumentace -- Pravidla pro bibliografick\'e odkazy a citace informa\v cn\'\i{}ch zdroj{\r u}},
  year         = {2011}
}

@inproceedings{awad,
  author    = {Awad, Muhammad A. and Ashkiani, Saman and Johnson, Rob and Farach-Colton, Mart\'{\i}n and Owens, John D.},
  title     = {Engineering a High-Performance GPU B-Tree},
  year      = {2019},
  isbn      = {9781450362252},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/3293883.3295706},
  doi       = {10.1145/3293883.3295706},
  abstract  = {We engineer a GPU implementation of a B-Tree that supports concurrent queries (point, range, and successor) and updates (insertions and deletions). Our B-tree outperforms the state of the art, a GPU log-structured merge tree (LSM) and a GPU sorted array. In particular, point and range queries are significantly faster than in a GPU LSM (the GPU LSM does not implement successor queries). Furthermore, B-Tree insertions are also faster than LSM and sorted array insertions unless insertions come in batches of more than roughly 100k. Because we cache the upper levels of the tree, we achieve lookup throughput that exceeds the DRAM bandwidth of the GPU. We demonstrate that the key limiter of performance on a GPU is contention and describe the design choices that allow us to achieve this high performance.},
  booktitle = {Proceedings of the 24th Symposium on Principles and Practice of Parallel Programming},
  pages     = {145–157},
  numpages  = {13},
  keywords  = {GPU, B-tree, mutable, dynamic, data structures},
  location  = {Washington, District of Columbia},
  series    = {PPoPP '19}
}

@article{goetz-tech,
  author     = {Graefe, Goetz},
  title      = {Modern B-Tree Techniques},
  year       = {2011},
  issue_date = {April 2011},
  publisher  = {Now Publishers Inc.},
  address    = {Hanover, MA, USA},
  volume     = {3},
  number     = {4},
  issn       = {1931-7883},
  url        = {https://doi.org/10.1561/1900000028},
  doi        = {10.1561/1900000028},
  abstract   = {Invented about 40 years ago and called ubiquitous less than 10 years later, B-tree indexes have been used in a wide variety of computing systems from handheld devices to mainframes and server farms. Over the years, many techniques have been added to the basic design in order to improve efficiency or to add functionality. Examples include separation of updates to structure or contents, utility operations such as non-logged yet transactional index creation, and robust query processing such as graceful degradation during index-to-index navigation.This survey reviews the basics of B-trees and of B-tree indexes in databases, transactional techniques and query processing techniques related to B-trees, B-tree utilities essential for database operations, and many optimizations and improvements. It is intended both as a survey and as a reference, enabling researchers to compare index innovations with advanced B-tree techniques and enabling professionals to select features, functions, and tradeoffs most appropriate for their data management challenges.},
  journal    = {Found. Trends Databases},
  month      = apr,
  pages      = {203–402},
  numpages   = {200}
}

@article{goetz-lock,
  author     = {Graefe, Goetz},
  title      = {A Survey of B-Tree Locking Techniques},
  year       = {2010},
  issue_date = {July 2010},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {35},
  number     = {3},
  issn       = {0362-5915},
  url        = {https://doi.org/10.1145/1806907.1806908},
  doi        = {10.1145/1806907.1806908},
  abstract   = {B-trees have been ubiquitous in database management systems for several decades, and they are used in other storage systems as well. Their basic structure and basic operations are well and widely understood including search, insertion, and deletion. Concurrency control of operations in B-trees, however, is perceived as a difficult subject with many subtleties and special cases. The purpose of this survey is to clarify, simplify, and structure the topic of concurrency control in B-trees by dividing it into two subtopics and exploring each of them in depth.},
  journal    = {ACM Trans. Database Syst.},
  month      = jul,
  articleno  = {16},
  numpages   = {26}
}

@article{jaluta,
  author     = {Jaluta, Ibrahim and Sippu, Seppo and Soisalon-Soininen, Eljas},
  title      = {Concurrency Control and Recovery for Balanced B-Link Trees},
  year       = {2005},
  issue_date = {April 2005},
  publisher  = {Springer-Verlag},
  address    = {Berlin, Heidelberg},
  volume     = {14},
  number     = {2},
  issn       = {1066-8888},
  url        = {https://doi.org/10.1007/s00778-004-0140-6},
  doi        = {10.1007/s00778-004-0140-6},
  abstract   = {In this paper we present new concurrent and recoverable B-link-tree algorithms. Unlike previous algorithms, ours maintain the balance of the B-link tree at all times, so that a logarithmic time bound for a search or an update operation is guaranteed under arbitrary sequences of record insertions and deletions. A database transaction can contain any number of operations of the form “fetch the first (or next) matching record”, “insert a record”, or “delete a record”, where database records are identified by their primary keys. Repeatable-read-level isolation for transactions is guaranteed by key-range locking. The algorithms apply the write-ahead logging (WAL) protocol and the steal and no-force buffering policies for index and data pages. Record inserts and deletes on leaf pages of a B-link tree are logged using physiological redo-undo log records. Each structure modification such as a page split or merge is made an atomic action by keeping the pages involved in the modification latched for the (short) duration of the modification and the logging of that modification; at most two B-link-tree pages are kept X-latched at a time. Each structure modification brings the B-link tree into a structurally consistent and balanced state whenever the tree was structurally consistent and balanced initially. Each structure modification is logged using a single physiological redo-only log record. Thus, a structure modification will never be undone even if the transaction that gave rise to it eventually aborts. In restart recovery, the redo pass of our ARIES-based recovery protocol will always produce a structurally consistent and balanced B-link tree, on which the database updates by backward-rolling transactions can always be undone logically, when a physical (page-oriented) undo is no longer possible.},
  journal    = {The VLDB Journal},
  month      = apr,
  pages      = {257–277},
  numpages   = {21},
  keywords   = {Recovery, Concurrency control, Tree-structure modifications, Transaction}
}

@article{lehman,
  author     = {Lehman, Philip L. and Yao, s. Bing},
  title      = {Efficient Locking for Concurrent Operations on B-Trees},
  year       = {1981},
  issue_date = {Dec. 1981},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {6},
  number     = {4},
  issn       = {0362-5915},
  url        = {https://doi.org/10.1145/319628.319663},
  doi        = {10.1145/319628.319663},
  abstract   = {The B-tree and its variants have been found to be highly useful (both theoretically and in practice) for storing large amounts of information, especially on secondary storage devices. We examine the problem of overcoming the inherent difficulty of concurrent operations on such structures, using a practical storage model. A single additional “link” pointer in each node allows a process to easily recover from tree modifications performed by other concurrent processes. Our solution compares favorably with earlier solutions in that the locking scheme is simpler (no read-locks are used) and only a (small) constant number of nodes are locked by any update process at any given time. An informal correctness proof for our system is given.},
  journal    = {ACM Trans. Database Syst.},
  month      = dec,
  pages      = {650–670},
  numpages   = {21},
  keywords   = {index organizations, correctness, B-tree, database, multiway search trees, consistencey, locking protocols, concurrency controls, data structures, concurrenct algorithms}
}

@inproceedings{kaczmarski,
  title        = {B+-tree optimized for GPGPU},
  author       = {Kaczmarski, Krzysztof},
  booktitle    = {OTM Confederated International Conferences On the Move to Meaningful Internet Systems},
  pages        = {843--854},
  year         = {2012},
  organization = {Springer}
}